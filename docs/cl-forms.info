This is cl-forms.info, produced by makeinfo version 6.7 from
cl-forms.texi.

Copyright (C) 2021 Mariano Montone

INFO-DIR-SECTION Common Lisp
START-INFO-DIR-ENTRY
* Cl-Forms: (cl-forms)Common Lisp client for ODATA services.
END-INFO-DIR-ENTRY


File: cl-forms.info,  Node: Top,  Next: Intro,  Up: (dir)

Top
***

_CL-FORMS_ is a Common Lisp client for accessing ODATA services.

* Menu:

* Intro::
* Installation::
* Usage::
* API::
* Index::


File: cl-forms.info,  Node: Intro,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

CL-FORMS is a web forms handling library for Common Lisp.

   Although it is potentially framework agnostic, it runs on top of
Hunchentoot at the moment.

   It features:

   * Several form field types: String, boolean, integer, email, password
     fields.  And more.
   * Custom fields.  CL-FORMS is extensible and it is possible to define
     new field types.
   * Server and client side validation
   * Rendering backends.  Forms can be rendered via CL-WHO, or Djula, or
     something else; the backend is pluggable.  The default renderer is
     CL-WHO.
   * Themes (like Bootstrap)
   * Control on rendering and layout.
   * Handling of form errors.
   * CSRF protection


File: cl-forms.info,  Node: Installation,  Next: Usage,  Prev: Intro,  Up: Top

2 Installation
**************


File: cl-forms.info,  Node: Usage,  Next: API,  Prev: Installation,  Up: Top

3 Usage
*******

3.1 Basics
==========

Use *note DEFFORM: CL-FORMS:DEFFORM macro. to define a form.  Example:

     (defform fields-form (:action "/fields-post")
       ((name :string :value "")
        (ready :boolean :value t)
        (sex :choice :choices (list "Male" "Female") :value "Male")
        (submit :submit :label "Create")))

   On your web handler, grab the form via 'get-form', select a renderer
with 'with-form-renderer'and then render the form with 'render-form':

     (let ((form (forms::get-form 'fields-form)))
        (forms:with-form-renderer :who
           (forms:render-form form))

   To handle the form, grab it via 'get-form' and then call
'handle-request' (you should probably also call 'validate-form' after).
Then bind form fields via either 'with-form-field-values', that binds
the form field values; or 'with-form-fields' that binds the form fields.

     (let ((form (forms:get-form 'fields-form)))
         (forms::handle-request form)
         (forms::with-form-field-values (name ready sex) form
            (who:with-html-output (forms.who::*html*)
               (:ul
                 (:li (who:fmt "Name: ~A" name))
                 (:li (who:fmt "Ready: ~A" ready))
                 (:li (who:fmt "Sex: ~A" sex))))))

   Plase have a look at the demo sources for more examples of how to use
the library

3.2 Demo
========

There's a demo included.  To run:

     (require :cl-forms.demo)
     (forms.test:run-demo)

3.2.1 Basic example
-------------------

Define a form.  Render the form via CL-WHO backend, doing:

     (forms:with-form-renderer :who
        (forms:render-form form))

   Then handle and validate the form.

   Source code:

     (in-package :forms.test)

     (forms:defform fields-form (:action "/fields-post"
                                         :enctype "multipart/form-data")
       ((name :string :value "")
        (ready :boolean :value t)
        (sex :choice :choices (list "Male" "Female") :value "Male")
        (avatar :file :upload-handler 'handle-file-upload)
        (disabled :string :disabled-p t :required-p nil)
        (readonly :string :read-only-p t :required-p nil)
        (readonly-checkbox :boolean :read-only-p t :required-p nil)
        (disabled-checkbox :boolean :disabled-p t :required-p nil)
        (submit :submit :label "Create")))

     (defun fields-demo ()
       (who:with-html-output (forms.who::*html*)
         (:h1 (who:str "Fields example"))
         (:div :class :container
               (:div :class :row
                     (:div :class :heading
                           (:h3 (who:str "Simple form")))
                     (let ((form (forms::get-form 'fields-form)))
                       (forms:with-form-renderer :who
                         (forms:render-form form))))
               (:div :class :row
                     (:div :class :heading
                           (:h3 (who:str "Choices")))
                     (let ((form (forms::get-form 'choices-form)))
                       (forms:with-form-renderer :who
                         (forms:render-form form)))))))

     (hunchentoot:define-easy-handler (fields-demo-handler :uri "/fields") ()
       (render-demo-page :demo #'fields-demo
                         :source (asdf:system-relative-pathname :cl-forms.demo
                                                                "test/demo/fields.lisp")
                         :active-menu :fields))

     (hunchentoot:define-easy-handler (fields-form-post
                                       :uri "/fields-post"
                                       :default-request-type :post) ()
       (flet ((fields-post ()
                (let ((form (forms:get-form 'fields-form)))
                  (forms::handle-request form)
                  (forms::with-form-fields (name ready sex avatar) form
                    (who:with-html-output (forms.who::*html*)
                      (:ul
                       (:li (who:fmt "Name: ~A" (forms::field-value name)))
                       (:li (who:fmt "Ready: ~A" (forms::field-value ready)))
                       (:li (who:fmt "Sex: ~A" (forms::field-value sex)))
                       (:li (who:fmt "Avatar: ~A" (forms::file-name avatar))
                            (when (forms::file-name avatar)
                              (who:htm
                               (:img :width 200 :height 200
                                     :src (format nil "/files?f=~A" (forms::file-name avatar))))))))))))
         (render-demo-page :demo #'fields-post
                           :source (asdf:system-relative-pathname :cl-forms.demo
                                                                  "test/demo/fields.lisp")
                           :active-menu :fields)))

     ;; Choices widget test

     (forms:defform choices-form (:action "/choices-post")
       ((sex :choice
             :choices (list "Male" "Female")
             :value "Male")
        (sex2 :choice
              :choices (list "Male" "Female")
              :value "Female"
              :expanded t)
        (choices :choice
                 :choices (list "Foo" "Bar")
                 :value (list "Foo")
                 :multiple t)
        (choices2 :choice
                  :choices (list "Foo" "Bar")
                  :value (list "Bar")
                  :multiple t
                  :expanded  t)
        (submit :submit :label "Ok")))

     (hunchentoot:define-easy-handler (choices-form-post :uri "/choices-post"
                                                         :default-request-type :post) ()
       (flet ((choices-post ()
                (let ((form (forms:get-form 'choices-form)))
                  (forms::handle-request form)
                  (forms::validate-form form)
                  (forms::with-form-field-values (sex sex2 choices choices2) form
                    (who:with-html-output (forms.who::*html*)
                      (:ul
                       (:li (who:fmt "Sex: ~A" sex))
                       (:li (who:fmt "Sex2: ~A" sex2))
                       (:li (who:fmt "Choices: ~A" choices))
                       (:li (who:fmt "Choices2: ~A" choices2))))))))
         (render-demo-page :demo #'choices-post
                           :source (asdf:system-relative-pathname :cl-forms.demo
                                                                  "test/demo/fields.lisp")
                           :active-menu :fields)))

     ;; File handling

     (defvar *files* nil)
     (defvar *files-path* (pathname "/tmp/cl-forms/"))

     (defun handle-file-upload (file-field)
       ;; Store the file
       (let ((new-path (merge-pathnames
                            (forms::file-name file-field)
                            *files-path*)))
         (rename-file (forms::file-path file-field)
                      (ensure-directories-exist new-path))
         ;; Save for handler
         (push (cons (forms::file-name file-field)
                     (list new-path (forms::file-content-type file-field)))
               *files*)))

     (defun handle-uploaded-file ()
       (let ((finfo (cdr (assoc (hunchentoot:parameter "f") *files* :test #'equalp))))
         (hunchentoot:handle-static-file (first finfo) (second finfo))))

     (push
      (hunchentoot:create-prefix-dispatcher "/files" 'handle-uploaded-file)
      hunchentoot:*dispatch-table*)

3.2.2 Validation
----------------

Example of forms validation.

   Add Clavier constraints to the form.  Then call VALIDATE-FORM after
HANDLE-REQUEST.

     (in-package :forms.test)

     (forms:defform validated-form (:action "/validation-post"
                                            :client-validation nil)
       ((name :string :value "" :constraints (list (clavier:is-a-string)
                                                   (clavier:not-blank)
                                                   (clavier:len :max 5)))
        (single :boolean :value t)
        (sex :choice :choices (list "Male" "Female") :value "Male")
        (age :integer :constraints (list (clavier:is-an-integer)
                                         (clavier:greater-than -1)
                                         (clavier:less-than 200)))
        (email :email)
        (birth-date :date :required-p nil)
        (submit :submit :label "Create")))

     (defun validation-demo (&optional form)
       (forms:with-form-renderer :who
         (who:with-html-output (forms.who::*html*)
           (:h1 (who:str "Server side validation"))
           (:p (who:str "This is a demo of server side validation. Submit the form and play with the values to see how it works. Also look at field constraints in source code tab."))
           (let ((form (or form (forms::get-form 'validated-form))))
             (forms:render-form form)))))

     (hunchentoot:define-easy-handler (validated-form-post :uri "/validation-post"
                                                           :default-request-type :post) ()

       (flet ((validation-post ()
                (let ((form (forms:get-form 'validated-form)))
                  (forms::handle-request form)
                  (if (forms::validate-form form)
                      ;; The form is valid
                      (forms::with-form-field-values (name single sex age email birth-date) form
                        (who:with-html-output (forms.who::*html*)
                          (:ul
                           (:li (who:fmt "Name: ~A" name))
                           (:li (who:fmt "Single: ~A" single))
                           (:li (who:fmt "Sex: ~A" sex))
                           (:li (who:fmt "Age: ~A" age))
                           (:li (who:fmt "Email: ~A" email))
                           (:li (who:fmt "Birth date: ~A" birth-date)))))
                      ;; The form is not valid
                      (validation-demo form)))))
         (render-demo-page :demo #'validation-post
                           :source (asdf:system-relative-pathname :cl-forms.demo
                                                                  "test/demo/validation.lisp")
                           :active-menu :validation)))

     (hunchentoot:define-easy-handler (validation-demo-handler :uri "/validation") ()
       (render-demo-page :demo #'validation-demo
                         :source (asdf:system-relative-pathname :cl-forms.demo
                                                                "test/demo/validation.lisp")
                         :active-menu :validation))

3.2.3 Client validation
-----------------------

To validate in the client, just set ':client-validation' to 'T'.

     (in-package :forms.test)

     (forms:defform client-validated-form (:action "/client-validation-post"
                                                   :client-validation t)
       ((name :string :value "" :constraints (list (clavier:is-a-string)
                                                   (clavier:not-blank)
                                                   (clavier:len :max 5))
              :validation-triggers '(:focusin))
        (single :boolean :value t)
        (sex :choice :choices (list "Male" "Female") :value "Male")
        (age :integer :constraints (list (clavier:is-an-integer)
                                         (clavier:greater-than -1)
                                         (clavier:less-than 200)))
        (email :email)
        (submit :submit :label "Create")))

     (defun client-validation (&optional form)
       (let ((form (or form (forms::get-form 'client-validated-form))))
         (forms:with-form-renderer :who
           (who:with-html-output (forms.who::*html*)
             (:h1 (who:str "Client side validation"))
             (:p (who:str "This is an example of how client side validation works. Client side validation uses parsleyjs library for validating client side."))
             (:p (who:str "The interesting thing about the implementation is that validations are specified in the form definition, and are \"compiled\" to rules in javascript. Also, this example uses the exactly the same constraints than the server side validation demo."))
             (forms:render-form form)))))

     (hunchentoot:define-easy-handler (client-validation-handler
                                       :uri "/client-validation") ()
       (render-demo-page :demo #'client-validation
                         :source (asdf:system-relative-pathname :cl-forms.demo
                                                                "test/demo/client-validation.lisp")
                         :active-menu :client-validation))

     (hunchentoot:define-easy-handler (client-validation-post :uri "/client-validation/post" :default-request-type :post) ()
       (flet ((client-validation-post ()
                (let ((form (forms:get-form 'client-validated-form)))
                  (forms::handle-request form)
                  (if (forms::validate-form form)
                      ;; The form is valid
                      (forms::with-form-field-values (name single sex age email) form
                        (who:with-html-output (forms.who::*html*)
                          (:ul
                           (:li (who:fmt "Name: ~A" name))
                           (:li (who:fmt "Single: ~A" single))
                           (:li (who:fmt "Sex: ~A" sex))
                           (:li (who:fmt "Age: ~A" age))
                           (:li (who:fmt "Email: ~A" email)))))
                      ;; The form is not valid
                      (client-validation form)))))
         (render-demo-page :demo #'client-validation-post
                           :source (asdf:system-relative-pathname :cl-forms.demo
                                                                  "test/demo/client-validation.lisp")
                           :active-menu :client-validation)))

3.2.4 Models
------------

     (in-package :forms.test)

     (defclass person ()
       ((name :initarg :name
              :accessor person-name
              :initform nil)
        (single :initarg :single
                :accessor person-single
                :initform t)
        (sex :initarg :sex
             :accessor person-sex
             :initform :male)))

     (forms:defform-builder model-form (person)
       (make-instance 'forms::form
                      :name 'model-form
                      :model person
                      :action "/models-post"
                      :fields (forms::make-form-fields
                               `((name :string :label "Name"
                                               :accessor person-name)
                                 (single :boolean :label "Single"
                                                  :accessor person-single)
                                 (sex :choice :label "Sex"
                                              :choices (:male :female)
                                              :accessor person-sex
                                              :formatter format-sex)
                                 (submit :submit :label "Update")))))

     (defun format-sex (sex stream)
       (write-string
        (if (equalp sex :male) "Male" "Female")
        stream))

     (defun models-demo ()
       (who:with-html-output (forms.who::*html*)
         (:h1 (who:str "Form models"))
         (:p "Forms can be attached to model objects. Model objects are CLOS instances from where form values are read and written to.")
         (:p "To work with models, forms are defined via defform-builder instead of defform. A form-builder is a function that takes the model objects and attaches it to the form. The form needs to define the accessors to access the model for each form field.")
         (:p "This is an example of a form attached to a person object. Please have a look at the source code to see how it is done.")
         (render-model-form)))

     (defun render-model-form (&optional form)
       (let ((form (or form
                       (let ((person (make-instance 'person
                                                    :name "Foo"
                                                    :single t
                                                    :sex :male)))
                         (forms::get-form 'model-form person)))))
         (forms:with-form-renderer :who
           (forms:render-form form))))

     (hunchentoot:define-easy-handler (model-form :uri "/models") ()
       (render-demo-page :demo #'models-demo
                         :source (asdf:system-relative-pathname :cl-forms.demo
                                                                "test/demo/models.lisp")
                         :active-menu :models))

     (hunchentoot:define-easy-handler (model-form-post :uri "/models-post"
                                                       :default-request-type :post) ()
       (flet ((model-post ()
                (let ((person (make-instance 'person)))
                  (let ((form (forms:get-form 'model-form person)))
                    (forms::handle-request form)
                    (forms::validate-form form)
                    (who:with-html-output (forms.who::*html*)
                      (:ul
                       (:li (who:fmt "Name: ~A" (person-name person)))
                       (:li (who:fmt "Single: ~A" (person-single person)))
                       (:li (who:fmt "Sex: ~A" (person-sex person)))))))))
         (render-demo-page :demo #'model-post
                           :source (asdf:system-relative-pathname :cl-forms.demo
                                                                  "test/demo/models.lisp")
                           :active-menu :models)))

3.2.5 Composition
-----------------

     (in-package :forms.test)

     (forms:defform member-form ()
       ((name :string :value "" :required-p nil)
        (ready :boolean :value t :required-p nil)
        (sex :choice :choices (list "Male" "Female") :value "Male")))

     (forms:defform composition-form (:action "/composition-post")
       (
        ;; Subforms
        (main-member :subform :subform 'member-form)
        (secondary-member :subform :subform 'member-form)
           ;; Simple list
        (todo :list :type '(:string :required-p nil)
              :empty-item-predicate (lambda (field)
                                      (let ((val (forms:field-value field)))
                                        (or (null val)
                                            (string= val "")))))
       ;; Subform list
        (members :list :type '(:subform :subform member-form)
                 :empty-item-predicate (lambda (field)
                                         (let* ((subform (forms:field-value field))
                                                (val (forms:get-field-value subform 'name)))
                                           (or (null val)
                                               (string= val "")))))
        (save :submit :label "Save")))

     (defun form-composition-demo (&optional form)
       (let ((form (or form (get-form 'composition-form))))
         (forms:with-form-renderer :who
           (who:with-html-output (forms.who::*html*)
             (:h1 (who:str "Forms composition"))
             (:p (who:str "These are examples of subforms and the list field type"))
             (forms::render-form-start form)
             (:h2 (who:str "Subforms"))
             (:p (who:str "This is an example of subform composition. main-member and secondary-member are subforms."))
             (forms::render-field 'main-member form)
             (forms::render-field 'secondary-member form)
             (forms::render-field 'save form)
             (:h2 (who:str "List field"))
             (:p (who:str "This is an example of the list field. In this case, the list has elements of type string. To add an element to the list, fill in the input. To remove, empty the input."))
             (forms::render-field 'todo form)
             (forms::render-field 'save form)
             (:h2 (who:str "List of subforms"))
             (:p (who:str "This is the most complex example. This shows a list of subforms. Subforms are of type person. To add new persons, fill in their name. To remove, empty the name field."))
             (forms::render-field 'members form)
             (forms::render-field 'save form)
             (forms::render-form-end form)))))

     (hunchentoot:define-easy-handler (composition-demo :uri "/composition") ()
       (render-demo-page :demo #'form-composition-demo
                         :source (asdf:system-relative-pathname :cl-forms.demo
                                                                "test/demo/composition.lisp")
                         :active-menu :composition))

     (hunchentoot:define-easy-handler (composition-demo-post :uri "/composition-post") ()
       (let ((form (forms:get-form 'composition-form)))
         (forms:handle-request form)
         (render-demo-page :demo (lambda ()
                                   (form-composition-demo form))
                           :source (asdf:system-relative-pathname :cl-forms.demo
                                                                  "test/demo/composition.lisp")
                           :active-menu :composition)))


File: cl-forms.info,  Node: API,  Next: Index,  Prev: Usage,  Up: Top

4 API
*****

* Menu:

* CL-FORMS package::


File: cl-forms.info,  Node: CL-FORMS package,  Up: API

4.1 CL-FORMS package
====================

 -- PACKAGE: CL-FORMS

External definitions
====================

Variables
---------

 -- CL-FORMS: *BASE64-ENCODE*

     If T, encode form parameters in base64

Macros
------

 -- Macro: CL-FORMS:DEFFORM-BUILDER (form-name args &body body)

     Registers a function with arguments ARGS and body BODY as a form
     builder.

     BODY is expected to instantiate a FORM object using ARGS in some
     way.

     FORM-NAME is the symbol under which the FORM is registered.

     Use GET-FORM with FORM-NAME and expected arguments to obtain the
     registered form.

 -- Macro: CL-FORMS:WITH-FORM-RENDERER (renderer &body body)

     Bind *FORM-RENDERER* to RENDERER and evaluate BODY in that context.

 -- Macro: CL-FORMS:WITH-FORM-THEME (form-theme &body body)

     Bind *FORM-THEME* to FORM-THEME and evaluate BODY in that context.

 -- Macro: CL-FORMS:WITH-FORM (form &body body)

     Bind *FORM* to FORM and evaluate BODY in that context.

 -- Macro: CL-FORMS:DEFFORM (form-name args fields)

     Define a form at top-level.

     ARGS are the arguments passed to FORM class via MAKE-INSTANCE.
     FIELDS are the form field specs.

          (forms:defform client-validated-form (:action "/client-validation-post"
                                                        :client-validation t)
            ((name :string :value "" :constraints (list (clavier:is-a-string)
                                                        (clavier:not-blank)
                                                        (clavier:len :max 5))
                   :validation-triggers '(:focusin))
             (single :boolean :value t)
             (sex :choice :choices (list "Male" "Female") :value "Male")
             (age :integer :constraints (list (clavier:is-an-integer)
                                              (clavier:greater-than -1)
                                              (clavier:less-than 200)))
             (email :email)
             (submit :submit :label "Create")))

 -- Macro: CL-FORMS:WITH-FORM-FIELDS (fields form &body body)

     Bind FIELDS to the form fields in FORM under BODY.

          (with-form-field-values (name single sex age email) form
             (print (list name single sex age email)))

 -- Macro: CL-FORMS:WITH-FORM-TEMPLATE ((&optional form-var) form-name
          args &body body)

 -- Macro: CL-FORMS:WITH-FORM-FIELD-VALUES (fields form &body body)

Generic functions
-----------------

 -- Generic-Function: CL-FORMS:FIELD-FORMATTER (sb-pcl::object)

 -- Generic-Function: CL-FORMS:FIELD-PARSER (sb-pcl::object)

 -- Generic-Function: CL-FORMS:FIELD-VALID-P (form-field &optional
          (form))

 -- Generic-Function: CL-FORMS:FIELD-READER (field)

 -- Generic-Function: CL-FORMS:FIELD-WRITER (field)

 -- Generic-Function: CL-FORMS:FORMAT-FIELD-VALUE (form-field
          field-value &optional stream)

 -- Generic-Function: CL-FORMS:FIELD-VALUE (field)

 -- Generic-Function: CL-FORMS:FIELD-ACCESSOR (sb-pcl::object)

 -- Generic-Function: CL-FORMS:FORM-ERRORS (sb-pcl::object)

Functions
---------

 -- Function: CL-FORMS:GET-FORM (name &rest args)

     Get the form named NAME.

     ARGS is the list of arguments to pass to a possible form builder
     function.

     See: DEFFORM-BUILDER macro.

 -- Function: CL-FORMS:GET-FIELD (form field-name &optional (error-p t))

 -- Function: CL-FORMS:HANDLE-REQUEST (&optional (form *form*) (request
          hunchentoot:*request*))

     Populates FORM from parameters in HTTP request.  After this, the
     form field contains values, but they are not validated.  To
     validate call VALIDATE-FORM after.

 -- Function: CL-FORMS:RENDER-FIELD-ERRORS (field &optional (form
          *form*) &rest args)

 -- Function: CL-FORMS:RENDER-FORM (&optional (form *form*) &rest args)

 -- Function: CL-FORMS:RENDER-FORM-START (&optional (form *form*) &rest
          args)

 -- Function: CL-FORMS:ADD-FORM-ERROR (field error-msg &optional (form
          *form*))

     Add an error on FIELD

 -- Function: CL-FORMS:RENDER-FORM-ERRORS (&optional (form *form*) &rest
          args)

 -- Function: CL-FORMS:RENDER-FIELD-WIDGET (field &optional (form
          *form*) &rest args)

 -- Function: CL-FORMS:FILL-FORM-FROM-MODEL (form model)

     Fill a FORM from a MODEL

 -- Function: CL-FORMS:VALIDATE-FORM (&optional (form *form*))

     Validates a form.  Usually called after HANDLE-REQUEST. Returns
     multiple values; first value is true if the form is valid; second
     value a list of errors.  The list of errors is an association list
     with elements (<field> .  <field errors strings list>).

 -- Function: CL-FORMS:MAKE-FORMATTER (symbol)

     Create a field formatter.  SYMBOL is the function to call.

 -- Function: CL-FORMS:RENDER-FIELD-LABEL (field &optional (form *form*)
          &rest args)

 -- Function: CL-FORMS:ADD-FIELD (form field)

 -- Function: CL-FORMS:REMOVE-FIELD (form field)

 -- Function: CL-FORMS:GET-FIELD-VALUE (form field-name &optional
          (error-p t))

 -- Function: CL-FORMS:FORM-VALID-P (form)

 -- Function: CL-FORMS:RENDER-FIELD (field &optional (form *form*) &rest
          args)

 -- Function: CL-FORMS:FILL-MODEL-FROM-FORM (form model)

     Set a MODEL's values from FORM field values

 -- Function: CL-FORMS:SET-FIELD-VALUE (form field-name value)

 -- Function: CL-FORMS:FORMAT-FIELD-VALUE-TO-STRING (form-field
          &optional (field-value (field-value form-field)))

 -- Function: CL-FORMS:RENDER-FORM-END (&optional (form *form*))

Classes
-------

 -- Class: CL-FORMS:FORM

     A form

     Class precedence list: 'form, standard-object, t'

     Slots:
        * 'id' -- initarg: ':id'; reader: 'cl-forms::form-id'; writer:
          '(setf cl-forms::form-id)'

          The form id
        * 'name' -- initarg: ':name'; reader: 'cl-forms::form-name';
          writer: '(setf cl-forms::form-name)'

          The form name
        * 'action' -- initarg: ':action'; reader:
          'cl-forms::form-action'; writer:
          '(setf cl-forms::form-action)'

          The form action
        * 'method' -- initarg: ':method'; reader:
          'cl-forms::form-method'; writer:
          '(setf cl-forms::form-method)'

          The form method
        * 'enctype' -- initarg: ':enctype'; reader:
          'cl-forms::form-enctype'; writer:
          '(setf cl-forms::form-enctype)'

          Form encoding type.  i.e.  Use multipart/form-data for file
          uploads
        * 'fields' -- initarg: ':fields'; reader:
          'cl-forms::form-fields'; writer:
          '(setf cl-forms::form-fields)'

          Form fields
        * 'model' -- initarg: ':model'; reader: 'cl-forms::form-model';
          writer: '(setf cl-forms::form-model)'

          The form model object
        * 'csrf-protection' -- initarg: ':csrf-protection'; reader:
          'cl-forms::form-csrf-protection-p'; writer:
          '(setf cl-forms::form-csrf-protection-p)'

          T when csrf protection is enabled
        * 'csrf-field-name' -- initarg: ':csrf-field-name'; reader:
          'cl-forms::form-csrf-field-name'; writer:
          '(setf cl-forms::form-csrf-field-name)'

          csrf field name
        * 'errors' -- reader: 'cl-forms:form-errors'; writer:
          '(setf cl-forms:form-errors)'

          Form errors after validation.  An association list with
          elements (<field> .  <field errors strings list>).
        * 'display-errors' -- initarg: ':display-errors'; reader:
          'cl-forms::display-errors'; writer:
          '(setf cl-forms::display-errors)'

          A list containing the places where to display errors.  Valid
          options are :list and :inline
        * 'client-validation' -- initarg: ':client-validation'; reader:
          'cl-forms::client-validation'; writer:
          '(setf cl-forms::client-validation)'

          When T, form client validation is enabled

 -- Class: CL-FORMS:FORM-FIELD

     A form field

     Class precedence list: 'form-field, standard-object, t'

     Slots:
        * 'name' -- initarg: ':name'; reader: 'cl-forms::field-name';
          writer: '(setf cl-forms::field-name)'

          The field name
        * 'label' -- initarg: ':label'; reader: 'cl-forms::field-label';
          writer: '(setf cl-forms::field-label)'

          The field label
        * 'value' -- initarg: ':value'

          Field value
        * 'default-value' -- initarg: ':default-value'; reader:
          'cl-forms::field-default-value'; writer:
          '(setf cl-forms::field-default-value)'

          Value to use when the field value is nil
        * 'placeholder' -- initarg: ':placeholder'; reader:
          'cl-forms::field-placeholder'; writer:
          '(setf cl-forms::field-placeholder)'

          Field placeholder (text that appears when the field is empty)
        * 'help-text' -- initarg: ':help-text'; reader:
          'cl-forms::field-help-text'; writer:
          '(setf cl-forms::field-help-text)'

          Field help text
        * 'parser' -- initarg: ':parser'; reader:
          'cl-forms:field-parser'; writer:
          '(setf cl-forms:field-parser)'

          Custom field value parser
        * 'formatter' -- initarg: ':formatter'; reader:
          'cl-forms:field-formatter'; writer:
          '(setf cl-forms:field-formatter)'

          The field formatter.  The function takes two arguments, a
          VALUE and STREAM to format it into.
        * 'constraints' -- initarg: ':constraints'; reader:
          'cl-forms::field-constraints'; writer:
          '(setf cl-forms::field-constraints)'

          A list of CLAVIER validators.
        * 'required' -- initarg: ':required-p'; reader:
          'cl-forms::field-required-p'; writer:
          '(setf cl-forms::field-required-p)'

          Whether the field is required
        * 'required-message' -- initarg: ':required-message'; reader:
          'cl-forms::field-required-message'; writer:
          '(setf cl-forms::field-required-message)'

          Message to display when field is required
        * 'invalid-message' -- initarg: ':invalid-message'; reader:
          'cl-forms::field-invalid-message'; writer:
          '(setf cl-forms::field-invalid-message)'

          Message to display when field is invalid
        * 'read-only' -- initarg: ':read-only-p'; reader:
          'cl-forms::field-read-only-p'; writer:
          '(setf cl-forms::field-read-only-p)'

          Whether the field is read only
        * 'disabled' -- initarg: ':disabled-p'; reader:
          'cl-forms::field-disabled-p'; writer:
          '(setf cl-forms::field-disabled-p)'

          Whether the field is disabled
        * 'accessor' -- initarg: ':accessor'; reader:
          'cl-forms:field-accessor'; writer:
          '(setf cl-forms:field-accessor)'

          The field accessor to the underlying model
        * 'reader' -- initarg: ':reader'

          The function to use to read from the underlying model
        * 'writer' -- initarg: ':writer'

          The function to use to write to underlying model
        * 'trim' -- initarg: ':trim-p'; reader:
          'cl-forms::field-trim-p'; writer:
          '(setf cl-forms::field-trim-p)'

          Trim the input
        * 'validation-triggers' -- initarg: ':validation-triggers';
          reader: 'cl-forms::field-validation-triggers'; writer:
          '(setf cl-forms::field-validation-triggers)'

          Client side validation triggers.  A list of :change, :focus,
          :focusout, :focusin, etc
        * 'form' -- initarg: ':form'; reader: 'cl-forms::field-form';
          writer: '(setf cl-forms::field-form)'

          The form the field belongs to


File: cl-forms.info,  Node: Index,  Prev: API,  Up: Top

5 Index
*******

 [index ]
* Menu:

* cl-forms:                              Top.                   (line 6)

 [index ]
* Menu:

* *BASE64-ENCODE*:                       CL-FORMS package.     (line 14)
* CL-FORMS:*BASE64-ENCODE*:              CL-FORMS package.     (line 14)

 [index ]
* Menu:

* CL-FORMS:ADD-FIELD:                    CL-FORMS package.    (line 160)
* CL-FORMS:ADD-FIELD <1>:                CL-FORMS package.    (line 160)
* CL-FORMS:ADD-FORM-ERROR:               CL-FORMS package.    (line 131)
* CL-FORMS:ADD-FORM-ERROR <1>:           CL-FORMS package.    (line 131)
* CL-FORMS:DEFFORM:                      CL-FORMS package.    (line  46)
* CL-FORMS:DEFFORM <1>:                  CL-FORMS package.    (line  46)
* CL-FORMS:DEFFORM-BUILDER:              CL-FORMS package.    (line  21)
* CL-FORMS:DEFFORM-BUILDER <1>:          CL-FORMS package.    (line  21)
* CL-FORMS:FIELD-ACCESSOR:               CL-FORMS package.    (line  98)
* CL-FORMS:FIELD-ACCESSOR <1>:           CL-FORMS package.    (line  98)
* CL-FORMS:FIELD-FORMATTER:              CL-FORMS package.    (line  82)
* CL-FORMS:FIELD-FORMATTER <1>:          CL-FORMS package.    (line  82)
* CL-FORMS:FIELD-PARSER:                 CL-FORMS package.    (line  84)
* CL-FORMS:FIELD-PARSER <1>:             CL-FORMS package.    (line  84)
* CL-FORMS:FIELD-READER:                 CL-FORMS package.    (line  89)
* CL-FORMS:FIELD-READER <1>:             CL-FORMS package.    (line  89)
* CL-FORMS:FIELD-VALID-P:                CL-FORMS package.    (line  86)
* CL-FORMS:FIELD-VALID-P <1>:            CL-FORMS package.    (line  86)
* CL-FORMS:FIELD-VALUE:                  CL-FORMS package.    (line  96)
* CL-FORMS:FIELD-VALUE <1>:              CL-FORMS package.    (line  96)
* CL-FORMS:FIELD-WRITER:                 CL-FORMS package.    (line  91)
* CL-FORMS:FIELD-WRITER <1>:             CL-FORMS package.    (line  91)
* CL-FORMS:FILL-FORM-FROM-MODEL:         CL-FORMS package.    (line 142)
* CL-FORMS:FILL-FORM-FROM-MODEL <1>:     CL-FORMS package.    (line 142)
* CL-FORMS:FILL-MODEL-FROM-FORM:         CL-FORMS package.    (line 172)
* CL-FORMS:FILL-MODEL-FROM-FORM <1>:     CL-FORMS package.    (line 172)
* CL-FORMS:FORM-ERRORS:                  CL-FORMS package.    (line 100)
* CL-FORMS:FORM-ERRORS <1>:              CL-FORMS package.    (line 100)
* CL-FORMS:FORM-VALID-P:                 CL-FORMS package.    (line 167)
* CL-FORMS:FORM-VALID-P <1>:             CL-FORMS package.    (line 167)
* CL-FORMS:FORMAT-FIELD-VALUE:           CL-FORMS package.    (line  93)
* CL-FORMS:FORMAT-FIELD-VALUE <1>:       CL-FORMS package.    (line  93)
* CL-FORMS:FORMAT-FIELD-VALUE-TO-STRING: CL-FORMS package.    (line 178)
* CL-FORMS:FORMAT-FIELD-VALUE-TO-STRING <1>: CL-FORMS package.
                                                              (line 178)
* CL-FORMS:GET-FIELD:                    CL-FORMS package.    (line 114)
* CL-FORMS:GET-FIELD <1>:                CL-FORMS package.    (line 114)
* CL-FORMS:GET-FIELD-VALUE:              CL-FORMS package.    (line 164)
* CL-FORMS:GET-FIELD-VALUE <1>:          CL-FORMS package.    (line 164)
* CL-FORMS:GET-FORM:                     CL-FORMS package.    (line 105)
* CL-FORMS:GET-FORM <1>:                 CL-FORMS package.    (line 105)
* CL-FORMS:HANDLE-REQUEST:               CL-FORMS package.    (line 116)
* CL-FORMS:HANDLE-REQUEST <1>:           CL-FORMS package.    (line 116)
* CL-FORMS:MAKE-FORMATTER:               CL-FORMS package.    (line 153)
* CL-FORMS:MAKE-FORMATTER <1>:           CL-FORMS package.    (line 153)
* CL-FORMS:REMOVE-FIELD:                 CL-FORMS package.    (line 162)
* CL-FORMS:REMOVE-FIELD <1>:             CL-FORMS package.    (line 162)
* CL-FORMS:RENDER-FIELD:                 CL-FORMS package.    (line 169)
* CL-FORMS:RENDER-FIELD <1>:             CL-FORMS package.    (line 169)
* CL-FORMS:RENDER-FIELD-ERRORS:          CL-FORMS package.    (line 123)
* CL-FORMS:RENDER-FIELD-ERRORS <1>:      CL-FORMS package.    (line 123)
* CL-FORMS:RENDER-FIELD-LABEL:           CL-FORMS package.    (line 157)
* CL-FORMS:RENDER-FIELD-LABEL <1>:       CL-FORMS package.    (line 157)
* CL-FORMS:RENDER-FIELD-WIDGET:          CL-FORMS package.    (line 139)
* CL-FORMS:RENDER-FIELD-WIDGET <1>:      CL-FORMS package.    (line 139)
* CL-FORMS:RENDER-FORM:                  CL-FORMS package.    (line 126)
* CL-FORMS:RENDER-FORM <1>:              CL-FORMS package.    (line 126)
* CL-FORMS:RENDER-FORM-END:              CL-FORMS package.    (line 181)
* CL-FORMS:RENDER-FORM-END <1>:          CL-FORMS package.    (line 181)
* CL-FORMS:RENDER-FORM-ERRORS:           CL-FORMS package.    (line 136)
* CL-FORMS:RENDER-FORM-ERRORS <1>:       CL-FORMS package.    (line 136)
* CL-FORMS:RENDER-FORM-START:            CL-FORMS package.    (line 128)
* CL-FORMS:RENDER-FORM-START <1>:        CL-FORMS package.    (line 128)
* CL-FORMS:SET-FIELD-VALUE:              CL-FORMS package.    (line 176)
* CL-FORMS:SET-FIELD-VALUE <1>:          CL-FORMS package.    (line 176)
* CL-FORMS:VALIDATE-FORM:                CL-FORMS package.    (line 146)
* CL-FORMS:VALIDATE-FORM <1>:            CL-FORMS package.    (line 146)
* CL-FORMS:WITH-FORM:                    CL-FORMS package.    (line  42)
* CL-FORMS:WITH-FORM <1>:                CL-FORMS package.    (line  42)
* CL-FORMS:WITH-FORM-FIELD-VALUES:       CL-FORMS package.    (line  77)
* CL-FORMS:WITH-FORM-FIELD-VALUES <1>:   CL-FORMS package.    (line  77)
* CL-FORMS:WITH-FORM-FIELDS:             CL-FORMS package.    (line  67)
* CL-FORMS:WITH-FORM-FIELDS <1>:         CL-FORMS package.    (line  67)
* CL-FORMS:WITH-FORM-RENDERER:           CL-FORMS package.    (line  34)
* CL-FORMS:WITH-FORM-RENDERER <1>:       CL-FORMS package.    (line  34)
* CL-FORMS:WITH-FORM-TEMPLATE:           CL-FORMS package.    (line  74)
* CL-FORMS:WITH-FORM-TEMPLATE <1>:       CL-FORMS package.    (line  74)
* CL-FORMS:WITH-FORM-THEME:              CL-FORMS package.    (line  38)
* CL-FORMS:WITH-FORM-THEME <1>:          CL-FORMS package.    (line  38)



Tag Table:
Node: Top244
Node: Intro445
Ref: introduction556
Node: Installation1236
Ref: installation1349
Node: Usage1349
Ref: usage1446
Node: API22757
Ref: api22843
Node: CL-FORMS package22874
Ref: CL-FORMS:*BASE64-ENCODE* variable23062
Ref: CL-FORMS:DEFFORM-BUILDER macro23153
Ref: CL-FORMS:WITH-FORM-RENDERER macro23543
Ref: CL-FORMS:WITH-FORM-THEME macro23679
Ref: CL-FORMS:WITH-FORM macro23813
Ref: CL-FORMS:DEFFORM macro23923
Ref: CL-FORMS:WITH-FORM-FIELDS macro24966
Ref: CL-FORMS:WITH-FORM-TEMPLATE macro25209
Ref: CL-FORMS:WITH-FORM-FIELD-VALUES macro25308
Ref: CL-FORMS:FIELD-FORMATTER function25414
Ref: CL-FORMS:FIELD-PARSER function25479
Ref: CL-FORMS:FIELD-VALID-P function25541
Ref: CL-FORMS:FIELD-READER function25627
Ref: CL-FORMS:FIELD-WRITER function25680
Ref: CL-FORMS:FORMAT-FIELD-VALUE function25733
Ref: CL-FORMS:FIELD-VALUE function25836
Ref: CL-FORMS:FIELD-ACCESSOR function25888
Ref: CL-FORMS:FORM-ERRORS function25952
Ref: CL-FORMS:GET-FORM function26034
Ref: CL-FORMS:GET-FIELD function26236
Ref: CL-FORMS:HANDLE-REQUEST function26310
Ref: CL-FORMS:RENDER-FIELD-ERRORS function26593
Ref: CL-FORMS:RENDER-FORM function26690
Ref: CL-FORMS:RENDER-FORM-START function26763
Ref: CL-FORMS:ADD-FORM-ERROR function26852
Ref: CL-FORMS:RENDER-FORM-ERRORS function26971
Ref: CL-FORMS:RENDER-FIELD-WIDGET function27061
Ref: CL-FORMS:FILL-FORM-FROM-MODEL function27158
Ref: CL-FORMS:VALIDATE-FORM function27247
Ref: CL-FORMS:MAKE-FORMATTER function27585
Ref: CL-FORMS:RENDER-FIELD-LABEL function27698
Ref: CL-FORMS:ADD-FIELD function27794
Ref: CL-FORMS:REMOVE-FIELD function27841
Ref: CL-FORMS:GET-FIELD-VALUE function27891
Ref: CL-FORMS:FORM-VALID-P function27981
Ref: CL-FORMS:RENDER-FIELD function28025
Ref: CL-FORMS:FILL-MODEL-FROM-FORM function28115
Ref: CL-FORMS:SET-FIELD-VALUE function28223
Ref: CL-FORMS:FORMAT-FIELD-VALUE-TO-STRING function28287
Ref: CL-FORMS:RENDER-FORM-END function28412
Ref: CL-FORMS:FORM class28495
Ref: CL-FORMS:FORM-FIELD class30869
Node: Index34647

End Tag Table
